
-- ===============================================================================
MODULE main
    VAR
        VC : Vehicle_Controller(VS.mode_event_HW, VS.mode_event_SW, VS.mode_event_Mech, VS.mode_event_Comm, VS.mode_event_Interaction, VS.init_state_HW, VS.init_state_SW, VS.init_state_Mech, VS.init_state_Comm, VS.init_state_Interaction, VS);
        VS : Vehicle_System(VC.cmd_to_HW, VC.cmd_to_SW, VC.cmd_to_Mech, VC.cmd_to_Comm, VC.cmd_to_Interaction);
        _masterCC : MasterCC#;

-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE Vehicle_Controller(mode_event_HW, mode_event_SW, mode_event_Mech, mode_event_Comm, mode_event_Interaction, init_state_HW, init_state_SW, init_state_Mech, init_state_Comm, init_state_Interaction, SC)
    VAR
        MN : Monitor(mode_event_HW, mode_event_SW, mode_event_Mech, mode_event_Comm, mode_event_Interaction, init_state_HW, init_state_SW, init_state_Mech, init_state_Comm, init_state_Interaction, cmd_to_HW, cmd_to_SW, cmd_to_Mech, cmd_to_Comm, cmd_to_Interaction);
    IVAR
        cmd_to_lidar : {cmd_on, cmd_off, nop};
        cmd_to_radar : {cmd_on, cmd_off, nop};
        cmd_to_gps : {cmd_on, cmd_off, nop};
        cmd_to_camera : {cmd_on, cmd_off, nop};
        cmd_to_wheel_encoder : {cmd_on, cmd_off, nop};
        cmd_to_HW_comm : {cmd_on, cmd_off, nop};
        cmd_to_HW_IR : {cmd_on, cmd_off, nop};
        cmd_to_HW_US : {cmd_on, cmd_off, nop};
        cmd_to_HW_INT : {cmd_on, cmd_off, nop};
        cmd_to_control_algorithm : {cmd_on, cmd_off, nop};
        cmd_to_software : {cmd_on, cmd_off, nop};
        cmd_to_steering_system : {cmd_on, cmd_off, nop};
        cmd_to_braking_system : {cmd_on, cmd_off, nop};
        cmd_to_conveyor_system : {cmd_on, cmd_off, nop};
        cmd_to_database : {cmd_on, cmd_off, nop};
        cmd_to_lte : {cmd_on, cmd_off, nop};
        cmd_to_command_generation : {cmd_on, cmd_off, nop};
        cmd_to_command_interpretation : {cmd_on, cmd_off, nop};

    DEFINE
        is_Passenger_interaction_functional := (MN.mode_est_CMDG = ok & MN.mode_est_CMDI = ok);
        is_Communication_functional := (MN.mode_est_COMM_DBMS = ok & MN.mode_est_COMM_LTE = ok);
        is_Software_functional := (MN.mode_est_SW_CA = ok & MN.mode_est_SW_SWF = ok);
        is_Mechanical_functional := ((MN.mode_est_MECH_STEER = ok & MN.mode_est_MECH_BRAK = ok) & MN.mode_est_MECH_CONV = ok);
        is_vehcile_running := ((((is_interaction_functional & is_HW_functional) & is_software_functional) & is_mechanical_functional) & is_communication_functional);
        is_interaction_functional := (MN.mode_est_CMDG = ok | MN.mode_est_CMDI = ok);
        is_communication_functional := (MN.mode_est_COMM_DBMS = ok & MN.mode_est_COMM_LTE = ok);
        is_mechanical_functional := ((MN.mode_est_MECH_STEER = ok & MN.mode_est_MECH_BRAK = ok) & MN.mode_est_MECH_CONV = ok);
        is_software_functional := (MN.mode_est_SW_SWF = ok & MN.mode_est_SW_CA = ok);
        is_HW_functional := ((is_primary_sensor_functional | is_backup_sensor_functional) & is_hardware_interaction_functional);
        is_hardware_interaction_functional := MN.mode_est_HW_INT = ok;
        is_backup_sensor_functional := ((MN.mode_est_HW_US = ok & MN.mode_est_HW_COMM = ok) & MN.mode_est_HW_IR = ok);
        is_primary_sensor_functional := ((((MN.mode_est_HW_LIDAR = ok & MN.mode_est_HW_RADAR = ok) & MN.mode_est_HW_GPS = ok) & MN.mode_est_HW_CAMERA = ok) & MN.mode_est_HW_WHEELENCODER = ok);

    DEFINE
        cmd_to_Interaction := [cmd_to_command_generation, cmd_to_command_interpretation];
        cmd_to_Comm := [cmd_to_database, cmd_to_lte];
        cmd_to_Mech := [cmd_to_steering_system, cmd_to_braking_system, cmd_to_conveyor_system];
        cmd_to_SW := [cmd_to_control_algorithm, cmd_to_software];
        cmd_to_HW := [cmd_to_lidar, cmd_to_radar, cmd_to_gps, cmd_to_camera, cmd_to_wheel_encoder, cmd_to_HW_comm, cmd_to_HW_US, cmd_to_HW_IR, cmd_to_HW_INT];


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE Monitor(mode_event_HW, mode_event_SW, mode_event_Mech, mode_event_Comm, mode_event_Interaction, init_state_HW, init_state_SW, init_state_Mech, init_state_Comm, init_state_Interaction, cmd_to_HW, cmd_to_SW, cmd_to_Mech, cmd_to_Comm, cmd_to_Interaction)
    VAR
        mode_est_HW_LIDAR : {ok, ko};
        mode_est_HW_RADAR : {ok, ko};
        mode_est_HW_GPS : {ok, ko};
        mode_est_HW_CAMERA : {ok, ko};
        mode_est_HW_WHEELENCODER : {ok, ko};
        mode_est_HW_COMM : {ok, ko};
        mode_est_HW_IR : {ok, ko};
        mode_est_HW_US : {ok, ko};
        mode_est_HW_INT : {ok, ko};
        mode_est_SW_CA : {ok, ko};
        mode_est_SW_SWF : {ok, ko};
        mode_est_MECH_STEER : {ok, ko};
        mode_est_MECH_BRAK : {ok, ko};
        mode_est_MECH_CONV : {ok, ko};
        mode_est_COMM_DBMS : {ok, ko};
        mode_est_COMM_LTE : {ok, ko};
        mode_est_CMDG : {ok, ko};
        mode_est_CMDI : {ok, ko};
        mode_est_HW_BP : {ok, ko};
        state_est_HW_LIDAR : {on, off};
        state_est_HW_RADAR : {on, off};
        state_est_HW_GPS : {on, off};
        state_est_HW_CAMERA : {on, off};
        state_est_HW_WHEELENCODER : {on, off};
        state_est_HW_COMM : {on, off};
        state_est_HW_IR : {on, off};
        state_est_HW_US : {on, off};
        state_est_HW_INT : {on, off};
        state_est_BC_STEER : {on, off};
        state_est_BC_BRAK : {on, off};
        state_est_BC_CONV : {on, off};
        state_est_B_CA : {on, off};
        state_est_B_SW : {on, off};
        state_est_DFP_CM : {on, off};
        state_est_DFP_TS : {on, off};
        state_est_DWP_DC : {on, off};
        state_est_DWP_H : {on, off};
        state_est_HW_BP : {on, off};

    DEFINE
        faults_counter := count(mode_est_HW_LIDAR != ok, mode_est_HW_RADAR != ok, mode_est_HW_GPS != ok, mode_est_HW_CAMERA != ok, mode_est_HW_WHEELENCODER != ok, mode_est_HW_COMM != ok, mode_est_HW_IR != ok, mode_est_HW_US != ok, mode_est_HW_INT != ok, mode_est_SW_CA != ok, mode_est_SW_SWF != ok, mode_est_MECH_STEER != ok, mode_est_MECH_BRAK != ok, mode_est_MECH_CONV != ok, mode_est_COMM_DBMS != ok, mode_est_COMM_LTE != ok, mode_est_CMDG != ok, mode_est_CMDI != ok, mode_est_HW_BP != ok);
        index_command_interpretation_element_short := 2;
        index_command_interpretation := 1;
        index_command_generation := 0;
        index_lte := 1;
        index_database := 0;
        index_conveyor_system := 2;
        index_braking_system := 1;
        index_steering_system := 0;
        index_software := 1;
        index_control_algorithm := 0;
        index_interaction_HW := 8;
        index_us := 7;
        index_ir := 6;
        index_comm := 5;
        index_wheel_encoder := 4;
        index_camera := 3;
        index_gps := 2;
        index_radar := 1;
        index_lidar := 0;
        nominal_event_INTERACT := mode_event_Interaction[1];
        nominal_event_COMM := mode_event_Comm[1];
        nominal_event_SW := mode_event_SW[1];
        nominal_event_MECH := mode_event_Mech[1];
        nominal_event_HW := mode_event_HW[1];
        fault_event_off_INTERACT := mode_event_Interaction[0];
        fault_event_off_COMM := mode_event_Comm[0];
        fault_event_off_SW := mode_event_SW[0];
        fault_event_off_MECH := mode_event_Mech[0];
        fault_event_off_HW := mode_event_HW[0];

    ASSIGN
        init(mode_est_HW_LIDAR) := ok;
        init(mode_est_HW_RADAR) := ok;
        init(mode_est_HW_GPS) := ok;
        init(mode_est_HW_CAMERA) := ok;
        init(mode_est_HW_WHEELENCODER) := ok;
        init(mode_est_HW_INT) := ok;
        init(mode_est_HW_COMM) := ok;
        init(mode_est_HW_IR) := ok;
        init(mode_est_HW_US) := ok;
        init(mode_est_MECH_STEER) := ok;
        init(mode_est_MECH_BRAK) := ok;
        init(mode_est_MECH_CONV) := ok;
        init(mode_est_SW_CA) := ok;
        init(mode_est_SW_SWF) := ok;
        init(mode_est_COMM_DBMS) := ok;
        init(mode_est_COMM_LTE) := ok;
        init(mode_est_CMDG) := ok;
        init(mode_est_CMDI) := ok;
        init(state_est_HW_LIDAR) := init_state_HW[index_lidar];
        init(state_est_HW_COMM) := init_state_HW[index_comm];
        init(state_est_HW_IR) := init_state_HW[index_ir];
        init(state_est_HW_RADAR) := init_state_HW[index_radar];
        init(state_est_HW_GPS) := init_state_HW[index_gps];
        init(state_est_HW_US) := init_state_HW[index_us];
        init(state_est_HW_CAMERA) := init_state_HW[index_camera];
        init(state_est_HW_WHEELENCODER) := init_state_HW[index_wheel_encoder];
        init(state_est_HW_INT) := init_state_HW[index_interaction_HW];
        init(state_est_BC_STEER) := init_state_Mech[index_steering_system];
        init(state_est_BC_BRAK) := init_state_Mech[index_braking_system];
        init(state_est_BC_CONV) := init_state_Mech[index_conveyor_system];
        init(state_est_B_CA) := init_state_SW[index_control_algorithm];
        init(state_est_B_SW) := init_state_SW[index_software];
        init(state_est_DFP_CM) := init_state_Comm[index_database];
        init(state_est_DFP_TS) := init_state_Comm[index_lte];
        init(state_est_DWP_DC) := init_state_Interaction[index_command_generation];
        init(state_est_DWP_H) := init_state_Interaction[index_command_interpretation];
        next(mode_est_HW_LIDAR) := case
fault_event_off_HW[index_lidar] : ko;
nominal_event_HW[index_lidar] : ok;
TRUE : mode_est_HW_LIDAR;
esac;

        next(mode_est_HW_RADAR) := case
fault_event_off_HW[index_radar] : ko;
nominal_event_HW[index_radar] : ok;
TRUE : mode_est_HW_RADAR;
esac;

        next(mode_est_HW_GPS) := case
fault_event_off_HW[index_gps] : ko;
nominal_event_HW[index_gps] : ok;
TRUE : mode_est_HW_GPS;
esac;

        next(mode_est_HW_CAMERA) := case
fault_event_off_HW[index_camera] : ko;
nominal_event_HW[index_camera] : ok;
TRUE : mode_est_HW_CAMERA;
esac;

        next(mode_est_HW_WHEELENCODER) := case
fault_event_off_HW[index_wheel_encoder] : ko;
nominal_event_HW[index_wheel_encoder] : ok;
TRUE : mode_est_HW_WHEELENCODER;
esac;

        next(mode_est_HW_COMM) := case
fault_event_off_HW[index_comm] : ko;
nominal_event_HW[index_comm] : ok;
TRUE : mode_est_HW_COMM;
esac;

        next(mode_est_HW_IR) := case
fault_event_off_HW[index_ir] : ko;
nominal_event_HW[index_ir] : ok;
TRUE : mode_est_HW_IR;
esac;

        next(mode_est_HW_US) := case
fault_event_off_HW[index_us] : ko;
nominal_event_HW[index_us] : ok;
TRUE : mode_est_HW_US;
esac;

        next(mode_est_HW_INT) := case
fault_event_off_HW[index_interaction_HW] : ko;
nominal_event_HW[index_interaction_HW] : ok;
TRUE : mode_est_HW_INT;
esac;

        next(mode_est_MECH_STEER) := case
fault_event_off_MECH[index_steering_system] : ko;
nominal_event_MECH[index_steering_system] : ok;
TRUE : mode_est_MECH_STEER;
esac;

        next(mode_est_MECH_BRAK) := case
fault_event_off_MECH[index_braking_system] : ko;
nominal_event_MECH[index_braking_system] : ok;
TRUE : mode_est_MECH_BRAK;
esac;

        next(mode_est_MECH_CONV) := case
fault_event_off_MECH[index_conveyor_system] : ko;
nominal_event_MECH[index_conveyor_system] : ok;
TRUE : mode_est_MECH_CONV;
esac;

        next(mode_est_SW_CA) := case
fault_event_off_SW[index_control_algorithm] : ko;
nominal_event_SW[index_control_algorithm] : ok;
TRUE : mode_est_SW_CA;
esac;

        next(mode_est_SW_SWF) := case
fault_event_off_SW[index_software] : ko;
nominal_event_SW[index_software] : ok;
TRUE : mode_est_SW_SWF;
esac;

        next(mode_est_COMM_DBMS) := case
fault_event_off_COMM[index_database] : ko;
nominal_event_COMM[index_database] : ok;
TRUE : mode_est_COMM_DBMS;
esac;

        next(mode_est_COMM_LTE) := case
fault_event_off_COMM[index_lte] : ko;
nominal_event_COMM[index_lte] : ok;
TRUE : mode_est_COMM_LTE;
esac;

        next(mode_est_CMDG) := case
fault_event_off_INTERACT[index_command_generation] : ko;
nominal_event_INTERACT[index_command_generation] : ok;
TRUE : mode_est_CMDG;
esac;

        next(mode_est_CMDI) := case
fault_event_off_INTERACT[index_command_interpretation] : ko;
nominal_event_INTERACT[index_command_interpretation] : ok;
TRUE : mode_est_CMDI;
esac;

        next(state_est_HW_LIDAR) := case
fault_event_off_HW[index_lidar] : off;
(next(mode_est_HW_LIDAR) = ok & cmd_to_HW[index_lidar] = cmd_on) : on;
(next(mode_est_HW_LIDAR) = ok & cmd_to_HW[index_lidar] = cmd_off) : off;
TRUE : state_est_HW_LIDAR;
esac;

        next(state_est_HW_COMM) := case
fault_event_off_HW[index_comm] : off;
(next(mode_est_HW_COMM) = ok & cmd_to_HW[index_comm] = cmd_on) : on;
(next(mode_est_HW_COMM) = ok & cmd_to_HW[index_comm] = cmd_off) : off;
TRUE : state_est_HW_COMM;
esac;

        next(state_est_HW_IR) := case
fault_event_off_HW[index_ir] : off;
(next(mode_est_HW_IR) = ok & cmd_to_HW[index_ir] = cmd_on) : on;
(next(mode_est_HW_IR) = ok & cmd_to_HW[index_ir] = cmd_off) : off;
TRUE : state_est_HW_IR;
esac;

        next(state_est_HW_RADAR) := case
fault_event_off_HW[index_radar] : off;
(next(mode_est_HW_RADAR) = ok & cmd_to_HW[index_radar] = cmd_on) : on;
(next(mode_est_HW_RADAR) = ok & cmd_to_HW[index_radar] = cmd_off) : off;
TRUE : state_est_HW_RADAR;
esac;

        next(state_est_HW_GPS) := case
fault_event_off_HW[index_gps] : off;
(next(mode_est_HW_GPS) = ok & cmd_to_HW[index_gps] = cmd_on) : on;
(next(mode_est_HW_GPS) = ok & cmd_to_HW[index_gps] = cmd_off) : off;
TRUE : state_est_HW_GPS;
esac;

        next(state_est_HW_US) := case
fault_event_off_HW[index_us] : off;
(next(mode_est_HW_US) = ok & cmd_to_HW[index_us] = cmd_on) : on;
(next(mode_est_HW_US) = ok & cmd_to_HW[index_us] = cmd_off) : off;
TRUE : state_est_HW_US;
esac;

        next(state_est_HW_CAMERA) := case
fault_event_off_HW[index_camera] : off;
(next(mode_est_HW_CAMERA) = ok & cmd_to_HW[index_camera] = cmd_on) : on;
(next(mode_est_HW_CAMERA) = ok & cmd_to_HW[index_camera] = cmd_off) : off;
TRUE : state_est_HW_CAMERA;
esac;

        next(state_est_HW_WHEELENCODER) := case
fault_event_off_HW[index_wheel_encoder] : off;
(next(mode_est_HW_WHEELENCODER) = ok & cmd_to_HW[index_wheel_encoder] = cmd_on) : on;
(next(mode_est_HW_WHEELENCODER) = ok & cmd_to_HW[index_wheel_encoder] = cmd_off) : off;
TRUE : state_est_HW_WHEELENCODER;
esac;

        next(state_est_HW_INT) := case
fault_event_off_HW[index_interaction_HW] : off;
(next(mode_est_HW_INT) = ok & cmd_to_HW[index_interaction_HW] = cmd_on) : on;
(next(mode_est_HW_INT) = ok & cmd_to_HW[index_interaction_HW] = cmd_off) : off;
TRUE : state_est_HW_INT;
esac;

        next(state_est_BC_STEER) := case
fault_event_off_MECH[index_steering_system] : off;
(next(mode_est_MECH_STEER) = ok & cmd_to_Mech[index_steering_system] = cmd_on) : on;
(next(mode_est_MECH_STEER) = ok & cmd_to_Mech[index_steering_system] = cmd_off) : off;
TRUE : state_est_BC_STEER;
esac;

        next(state_est_BC_BRAK) := case
fault_event_off_MECH[index_braking_system] : off;
(next(mode_est_MECH_BRAK) = ok & cmd_to_Mech[index_braking_system] = cmd_on) : on;
(next(mode_est_MECH_BRAK) = ok & cmd_to_Mech[index_braking_system] = cmd_off) : off;
TRUE : state_est_BC_BRAK;
esac;

        next(state_est_BC_CONV) := case
fault_event_off_MECH[index_conveyor_system] : off;
(next(mode_est_MECH_CONV) = ok & cmd_to_Mech[index_conveyor_system] = cmd_on) : on;
(next(mode_est_MECH_CONV) = ok & cmd_to_Mech[index_conveyor_system] = cmd_off) : off;
TRUE : state_est_BC_CONV;
esac;

        next(state_est_B_CA) := case
fault_event_off_SW[index_control_algorithm] : off;
(next(mode_est_SW_CA) = ok & cmd_to_SW[index_control_algorithm] = cmd_on) : on;
(next(mode_est_SW_CA) = ok & cmd_to_SW[index_control_algorithm] = cmd_off) : off;
TRUE : state_est_B_CA;
esac;

        next(state_est_B_SW) := case
fault_event_off_SW[index_software] : off;
(next(mode_est_SW_SWF) = ok & cmd_to_SW[index_software] = cmd_on) : on;
(next(mode_est_SW_SWF) = ok & cmd_to_SW[index_software] = cmd_off) : off;
TRUE : state_est_B_SW;
esac;

        next(state_est_DFP_CM) := case
fault_event_off_COMM[index_database] : off;
(next(mode_est_COMM_DBMS) = ok & cmd_to_Comm[index_database] = cmd_on) : on;
(next(mode_est_COMM_DBMS) = ok & cmd_to_Comm[index_database] = cmd_off) : off;
TRUE : state_est_DFP_CM;
esac;

        next(state_est_DFP_TS) := case
fault_event_off_COMM[index_lte] : off;
(next(mode_est_COMM_LTE) = ok & cmd_to_Comm[index_lte] = cmd_on) : on;
(next(mode_est_COMM_LTE) = ok & cmd_to_Comm[index_lte] = cmd_off) : off;
TRUE : state_est_DFP_TS;
esac;

        next(state_est_DWP_DC) := case
fault_event_off_INTERACT[index_command_generation] : off;
(next(mode_est_CMDG) = ok & cmd_to_Interaction[index_command_generation] = cmd_on) : on;
(next(mode_est_CMDG) = ok & cmd_to_Interaction[index_command_generation] = cmd_off) : off;
TRUE : state_est_DWP_DC;
esac;

        next(state_est_DWP_H) := case
fault_event_off_INTERACT[index_command_interpretation] : off;
(next(mode_est_CMDI) = ok & cmd_to_Interaction[index_command_interpretation] = cmd_on) : on;
(next(mode_est_CMDI) = ok & cmd_to_Interaction[index_command_interpretation] = cmd_off) : off;
TRUE : state_est_DWP_H;
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE Vehicle_System(cmd_to_HW, cmd_to_SW, cmd_to_Mech, cmd_to_Comm, cmd_to_Interaction)
    VAR
        HW : HardWare(cmd_to_HW);
        SW : SoftWare(cmd_to_SW);
        MECH : Mechanical(cmd_to_Mech);
        COMM : Communication(cmd_to_Comm);
        INTER : Interaction(cmd_to_Interaction);
    DEFINE
        init_state_Interaction := INTER.init_state_Interaction;
        init_state_Comm := COMM.init_state_Comm;
        init_state_Mech := MECH.init_state_Mech;
        init_state_SW := SW.init_state_SW;
        init_state_HW := HW.init_state_HW;
        mode_event_Interaction := INTER.mode_event_Interaction;
        mode_event_Comm := COMM.mode_event_Comm;
        mode_event_Mech := MECH.mode_event_Mech;
        mode_event_SW := SW.mode_event_SW;
        mode_event_HW := HW.mode_event_HW;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE HardWare(cmd)
    VAR
        IP : IntegerationPlatrom(cmd, index_integeration_platform);
        PS : PrimarySensor(cmd, index_primary_sensor);
        BS : BackupSensor(cmd, index_backup_sensor);
    DEFINE
        index_integeration_platform := 7;
        index_backup_sensor := 5;
        index_primary_sensor := 0;

    DEFINE
        init_state_HW := [PS.init_lidar, PS.init_radar, PS.init_gps, PS.init_camera, PS.init_wheel_encoder, BS.init_Comm, BS.init_IR, BS.init_US, IP.init_integeration_platform_hardware];
        mode_event_HW := [fault_event_HW, nominal_event_HW];
        nominal_event_HW := [PS.nominal_event_LIDAR, PS.nominal_event_RADAR, PS.nominal_event_GPS, PS.nominal_event_CAMERA, PS.nominal_event_WHEELENCODER, BS.nominal_event_COMM, BS.nominal_event_IR, BS.nominal_event_US, IP.nominal_event_INT_HW];
        fault_event_HW := [PS.fault_event_off_LIDAR, PS.fault_event_off_RADAR, PS.fault_event_off_GPS, PS.fault_event_off_CAMERA, PS.fault_event_off_WHEELENCODER, BS.fault_event_off_COMM, BS.fault_event_off_IR, BS.fault_event_off_US, IP.fault_event_off_INT_HW];


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE IntegerationPlatrom(cmd, index)
    VAR
        INT_HW : integeration_hardware_#Extended(cmd[index_integeration_platform_hardware], init_integeration_platform_hardware);
    DEFINE
        init_integeration_platform_hardware := off;
        index_integeration_platform_hardware := index + 0;
        nominal_event_INT_HW := INT_HW.nominal_event;
        fault_event_off_INT_HW := INT_HW.fault_event_stuck_at_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE integeration_hardware_#Extended(cmd, init_state)
    VAR
        HW_integeration_failure : HW_integeration_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := HW_integeration_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE HW_integeration_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        harware_integeration_failure : harware_integeration_failure_fm_Mod(mode = NOMINAL, mode_is_harware_integeration_failure, term_#1, state__#read, state__#write, event = harware_integeration_failure#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, harware_integeration_failure#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, harware_integeration_failure#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_harware_integeration_failure#FAULT := ((mode = NOMINAL & harware_integeration_failure.trans_trig_guard_#0) | (mode = harware_integeration_failure#FAULT & harware_integeration_failure.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_harware_integeration_failure : state__#write;
TRUE : state__#read;
esac;
        mode_is_harware_integeration_failure := mode = harware_integeration_failure#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in harware_integeration_failure#failure <-> failed_to_off#event);

    TRANS case
((mode = harware_integeration_failure#FAULT & harware_integeration_failure.trans_trig_guard_#1) | (mode = NOMINAL & harware_integeration_failure.trans_trig_guard_#0)) : next(mode) = harware_integeration_failure#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE harware_integeration_failure_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        harware_integeration_failureEM : harware_integeration_failure_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE harware_integeration_failure_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE PrimarySensor(cmd, index)
    VAR
        LIDAR : lidar_#Extended(cmd[index_lidar], init_lidar);
        RADAR : radar_#Extended(cmd[index_radar], init_radar);
        GPS : gps_#Extended(cmd[index_gps], init_gps);
        CAMERA : camera_#Extended(cmd[index_camera], init_camera);
        WHEELENCODER : wheelencoder_#Extended(cmd[index_wheel_encoder], init_wheel_encoder);
    DEFINE
        init_US := off;
        init_IR := on;
        init_Comm := off;
        init_wheel_encoder := off;
        init_camera := off;
        init_gps := off;
        init_radar := off;
        init_lidar := off;
        nominal_event_WHEELENCODER := WHEELENCODER.nominal_event;
        nominal_event_CAMERA := CAMERA.nominal_event;
        nominal_event_GPS := GPS.nominal_event;
        nominal_event_RADAR := RADAR.nominal_event;
        nominal_event_LIDAR := LIDAR.nominal_event;
        fault_event_off_WHEELENCODER := WHEELENCODER.fault_event_stuck_at_off;
        fault_event_off_CAMERA := CAMERA.fault_event_stuck_at_off;
        fault_event_off_GPS := GPS.fault_event_stuck_at_off;
        fault_event_off_RADAR := RADAR.fault_event_stuck_at_off;
        fault_event_off_LIDAR := LIDAR.fault_event_stuck_at_off;
        index_wheel_encoder := index + 4;
        index_camera := index + 3;
        index_gps := index + 2;
        index_radar := index + 1;
        index_lidar := index + 0;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE lidar_#Extended(cmd, init_state)
    VAR
        lidar_failed : lidar_failed_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := lidar_failed.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE lidar_failed_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        lidar_failed : lidar_failed_fm_Mod(mode = NOMINAL, mode_is_lidar_failed, term_#1, state__#read, state__#write, event = lidar_failed#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, lidar_failed#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, lidar_failed#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_lidar_failed#FAULT := ((mode = NOMINAL & lidar_failed.trans_trig_guard_#0) | (mode = lidar_failed#FAULT & lidar_failed.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_lidar_failed : state__#write;
TRUE : state__#read;
esac;
        mode_is_lidar_failed := mode = lidar_failed#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in lidar_failed#failure <-> failed_to_off#event);

    TRANS case
((mode = lidar_failed#FAULT & lidar_failed.trans_trig_guard_#1) | (mode = NOMINAL & lidar_failed.trans_trig_guard_#0)) : next(mode) = lidar_failed#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE lidar_failed_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        lidar_failedEM : lidar_failed_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE lidar_failed_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE radar_#Extended(cmd, init_state)
    VAR
        radar_failed : radar_failed_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := radar_failed.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE radar_failed_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        radar_failed : radar_failed_fm_Mod(mode = NOMINAL, mode_is_radar_failed, term_#1, state__#read, state__#write, event = radar_failed#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, radar_failed#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, radar_failed#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_radar_failed#FAULT := ((mode = NOMINAL & radar_failed.trans_trig_guard_#0) | (mode = radar_failed#FAULT & radar_failed.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_radar_failed : state__#write;
TRUE : state__#read;
esac;
        mode_is_radar_failed := mode = radar_failed#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in radar_failed#failure <-> failed_to_off#event);

    TRANS case
((mode = radar_failed#FAULT & radar_failed.trans_trig_guard_#1) | (mode = NOMINAL & radar_failed.trans_trig_guard_#0)) : next(mode) = radar_failed#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE radar_failed_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        radar_failedEM : radar_failed_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE radar_failed_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE gps_#Extended(cmd, init_state)
    VAR
        gps_failed : gps_failed_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := gps_failed.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE gps_failed_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        gps_failed : gps_failed_fm_Mod(mode = NOMINAL, mode_is_gps_failed, term_#1, state__#read, state__#write, event = gps_failed#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, gps_failed#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, gps_failed#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_gps_failed#FAULT := ((mode = NOMINAL & gps_failed.trans_trig_guard_#0) | (mode = gps_failed#FAULT & gps_failed.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_gps_failed : state__#write;
TRUE : state__#read;
esac;
        mode_is_gps_failed := mode = gps_failed#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in gps_failed#failure <-> failed_to_off#event);

    TRANS case
((mode = gps_failed#FAULT & gps_failed.trans_trig_guard_#1) | (mode = NOMINAL & gps_failed.trans_trig_guard_#0)) : next(mode) = gps_failed#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE gps_failed_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        gps_failedEM : gps_failed_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE gps_failed_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE camera_#Extended(cmd, init_state)
    VAR
        camera_failed : camera_failed_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := camera_failed.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE camera_failed_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        camera_failed : camera_failed_fm_Mod(mode = NOMINAL, mode_is_camera_failed, term_#1, state__#read, state__#write, event = camera_failed#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, camera_failed#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, camera_failed#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_camera_failed#FAULT := ((mode = NOMINAL & camera_failed.trans_trig_guard_#0) | (mode = camera_failed#FAULT & camera_failed.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_camera_failed : state__#write;
TRUE : state__#read;
esac;
        mode_is_camera_failed := mode = camera_failed#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in camera_failed#failure <-> failed_to_off#event);

    TRANS case
((mode = camera_failed#FAULT & camera_failed.trans_trig_guard_#1) | (mode = NOMINAL & camera_failed.trans_trig_guard_#0)) : next(mode) = camera_failed#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE camera_failed_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        camera_failedEM : camera_failed_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE camera_failed_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE wheelencoder_#Extended(cmd, init_state)
    VAR
        wheel_encoder_failed : wheel_encoder_failed_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := wheel_encoder_failed.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE wheel_encoder_failed_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        wheel_encoder_failed : wheel_encoder_failed_fm_Mod(mode = NOMINAL, mode_is_wheel_encoder_failed, term_#1, state__#read, state__#write, event = wheel_encoder_failed#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, wheel_encoder_failed#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, wheel_encoder_failed#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_wheel_encoder_failed#FAULT := ((mode = NOMINAL & wheel_encoder_failed.trans_trig_guard_#0) | (mode = wheel_encoder_failed#FAULT & wheel_encoder_failed.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_wheel_encoder_failed : state__#write;
TRUE : state__#read;
esac;
        mode_is_wheel_encoder_failed := mode = wheel_encoder_failed#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in wheel_encoder_failed#failure <-> failed_to_off#event);

    TRANS case
((mode = wheel_encoder_failed#FAULT & wheel_encoder_failed.trans_trig_guard_#1) | (mode = NOMINAL & wheel_encoder_failed.trans_trig_guard_#0)) : next(mode) = wheel_encoder_failed#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE wheel_encoder_failed_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        wheel_encoder_failedEM : wheel_encoder_failed_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE wheel_encoder_failed_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE BackupSensor(cmd, index)
    VAR
        COMM : comm_#Extended(cmd[index_comm], init_Comm);
        IR : ir_#Extended(cmd[index_ir], init_IR);
        US : us_#Extended(cmd[index_us], init_US);
    DEFINE
        init_US := off;
        init_IR := off;
        init_Comm := off;
        index_us := index + 2;
        index_ir := index + 1;
        index_comm := index + 0;
        nominal_event_US := US.nominal_event;
        nominal_event_IR := IR.nominal_event;
        nominal_event_COMM := COMM.nominal_event;
        fault_event_off_US := US.fault_event_stuck_at_off;
        fault_event_off_IR := IR.fault_event_stuck_at_off;
        fault_event_off_COMM := COMM.fault_event_stuck_at_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE comm_#Extended(cmd, init_state)
    VAR
        communication_failure : communication_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := communication_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE communication_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        backup_sensor_communication_failure : backup_sensor_communication_failure_fm_Mod(mode = NOMINAL, mode_is_backup_sensor_communication_failure, term_#1, state__#read, state__#write, event = backup_sensor_communication_failure#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, backup_sensor_communication_failure#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, backup_sensor_communication_failure#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_backup_sensor_communication_failure#FAULT := ((mode = NOMINAL & backup_sensor_communication_failure.trans_trig_guard_#0) | (mode = backup_sensor_communication_failure#FAULT & backup_sensor_communication_failure.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_backup_sensor_communication_failure : state__#write;
TRUE : state__#read;
esac;
        mode_is_backup_sensor_communication_failure := mode = backup_sensor_communication_failure#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in backup_sensor_communication_failure#failure <-> failed_to_off#event);

    TRANS case
((mode = backup_sensor_communication_failure#FAULT & backup_sensor_communication_failure.trans_trig_guard_#1) | (mode = NOMINAL & backup_sensor_communication_failure.trans_trig_guard_#0)) : next(mode) = backup_sensor_communication_failure#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE backup_sensor_communication_failure_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        backup_sensor_communication_failureEM : backup_sensor_communication_failure_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE backup_sensor_communication_failure_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE ir_#Extended(cmd, init_state)
    VAR
        ir_failure : ir_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := ir_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE ir_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        backup_sensor_ir_failure : backup_sensor_ir_failure_fm_Mod(mode = NOMINAL, mode_is_backup_sensor_ir_failure, term_#1, state__#read, state__#write, event = backup_sensor_ir_failure#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, backup_sensor_ir_failure#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, backup_sensor_ir_failure#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_backup_sensor_ir_failure#FAULT := ((mode = NOMINAL & backup_sensor_ir_failure.trans_trig_guard_#0) | (mode = backup_sensor_ir_failure#FAULT & backup_sensor_ir_failure.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_backup_sensor_ir_failure : state__#write;
TRUE : state__#read;
esac;
        mode_is_backup_sensor_ir_failure := mode = backup_sensor_ir_failure#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in backup_sensor_ir_failure#failure <-> failed_to_off#event);

    TRANS case
((mode = backup_sensor_ir_failure#FAULT & backup_sensor_ir_failure.trans_trig_guard_#1) | (mode = NOMINAL & backup_sensor_ir_failure.trans_trig_guard_#0)) : next(mode) = backup_sensor_ir_failure#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE backup_sensor_ir_failure_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        backup_sensor_ir_failureEM : backup_sensor_ir_failure_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE backup_sensor_ir_failure_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE us_#Extended(cmd, init_state)
    VAR
        us_failure : us_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := us_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE us_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        backup_sensor_us_failure : backup_sensor_us_failure_fm_Mod(mode = NOMINAL, mode_is_backup_sensor_us_failure, term_#1, state__#read, state__#write, event = backup_sensor_us_failure#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, backup_sensor_us_failure#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, backup_sensor_us_failure#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_backup_sensor_us_failure#FAULT := ((mode = NOMINAL & backup_sensor_us_failure.trans_trig_guard_#0) | (mode = backup_sensor_us_failure#FAULT & backup_sensor_us_failure.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_backup_sensor_us_failure : state__#write;
TRUE : state__#read;
esac;
        mode_is_backup_sensor_us_failure := mode = backup_sensor_us_failure#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in backup_sensor_us_failure#failure <-> failed_to_off#event);

    TRANS case
((mode = backup_sensor_us_failure#FAULT & backup_sensor_us_failure.trans_trig_guard_#1) | (mode = NOMINAL & backup_sensor_us_failure.trans_trig_guard_#0)) : next(mode) = backup_sensor_us_failure#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE backup_sensor_us_failure_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        backup_sensor_us_failureEM : backup_sensor_us_failure_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE backup_sensor_us_failure_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE SoftWare(cmd)
    VAR
        CA : controlalgorithm_#Extended(cmd[index_control_algorithm], init_control_algorithm);
        SW : softwarefailures_#Extended(cmd[index_software], init_software);
    DEFINE
        init_software := off;
        init_control_algorithm := off;
        is_functional := (fault_event_failed_algorithm & fault_event_failed_software);
        nominal_event_software := SW.nominal_event;
        nomina_event_control_algorithm := CA.nominal_event;
        fault_event_failed_software := SW.fault_event_stuck_at_off;
        fault_event_failed_algorithm := CA.fault_event_stuck_at_off;
        index_software := 1;
        index_control_algorithm := 0;

    DEFINE
        init_state_SW := [init_control_algorithm, init_software];
        mode_event_SW := [fault_event_failed_SW, nominal_event_SW];
        nominal_event_SW := [nomina_event_control_algorithm, nominal_event_software];
        fault_event_failed_SW := [fault_event_failed_algorithm, fault_event_failed_software];


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE controlalgorithm_#Extended(cmd, init_state)
    VAR
        SW_control_algorithm_failure : SW_control_algorithm_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := SW_control_algorithm_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE SW_control_algorithm_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        SW_CA_fail : SW_CA_fail_fm_Mod(mode = NOMINAL, mode_is_SW_CA_fail, term_#1, state__#read, state__#write, event = SW_CA_fail#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, SW_CA_fail#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, SW_CA_fail#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_SW_CA_fail#FAULT := ((mode = NOMINAL & SW_CA_fail.trans_trig_guard_#0) | (mode = SW_CA_fail#FAULT & SW_CA_fail.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_SW_CA_fail : state__#write;
TRUE : state__#read;
esac;
        mode_is_SW_CA_fail := mode = SW_CA_fail#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in SW_CA_fail#failure <-> failed_to_off#event);

    TRANS case
((mode = SW_CA_fail#FAULT & SW_CA_fail.trans_trig_guard_#1) | (mode = NOMINAL & SW_CA_fail.trans_trig_guard_#0)) : next(mode) = SW_CA_fail#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE SW_CA_fail_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        SW_CA_failEM : SW_CA_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE SW_CA_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE softwarefailures_#Extended(cmd, init_state)
    VAR
        SW_software_failure : SW_software_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := SW_software_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE SW_software_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        SW_SW_fail : SW_SW_fail_fm_Mod(mode = NOMINAL, mode_is_SW_SW_fail, term_#1, state__#read, state__#write, event = SW_SW_fail#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, SW_SW_fail#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, SW_SW_fail#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_SW_SW_fail#FAULT := ((mode = NOMINAL & SW_SW_fail.trans_trig_guard_#0) | (mode = SW_SW_fail#FAULT & SW_SW_fail.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_SW_SW_fail : state__#write;
TRUE : state__#read;
esac;
        mode_is_SW_SW_fail := mode = SW_SW_fail#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in SW_SW_fail#failure <-> failed_to_off#event);

    TRANS case
((mode = SW_SW_fail#FAULT & SW_SW_fail.trans_trig_guard_#1) | (mode = NOMINAL & SW_SW_fail.trans_trig_guard_#0)) : next(mode) = SW_SW_fail#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE SW_SW_fail_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        SW_SW_failEM : SW_SW_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE SW_SW_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE Mechanical(cmd)
    VAR
        STEER : steering_#Extended(cmd[index_steering_system], init_steering_system);
        BRAK : braking_#Extended(cmd[index_braking_system], init_braking_system);
        CONV : conveyor_#Extended(cmd[index_conveyor_system], init_conveyor_system);
    DEFINE
        init_conveyor_system := off;
        init_braking_system := off;
        init_steering_system := off;
        is_functional := count(fault_event_off_steering_system, fault_event_off_braking_system, fault_event_off_conveyor_system) = 0;
        nominal_event_conveyor_system := CONV.nominal_event;
        nominal_event_SWraking_system := BRAK.nominal_event;
        nominal_event_steering_system := STEER.nominal_event;
        fault_event_off_conveyor_system := CONV.fault_event_stuck_at_off;
        fault_event_off_braking_system := BRAK.fault_event_stuck_at_off;
        fault_event_off_steering_system := STEER.fault_event_stuck_at_off;
        index_conveyor_system := 2;
        index_braking_system := 1;
        index_steering_system := 0;

    DEFINE
        init_state_Mech := [init_steering_system, init_braking_system, init_conveyor_system];
        mode_event_Mech := [fault_event_Mech, nominal_event_Mech];
        nominal_event_Mech := [nominal_event_steering_system, nominal_event_SWraking_system, nominal_event_conveyor_system];
        fault_event_Mech := [fault_event_off_steering_system, fault_event_off_braking_system, fault_event_off_conveyor_system];


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE steering_#Extended(cmd, init_state)
    VAR
        MECH_steering_failure : MECH_steering_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := MECH_steering_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE MECH_steering_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        MECH_steering_fail : MECH_steering_fail_fm_Mod(mode = NOMINAL, mode_is_MECH_steering_fail, term_#1, state__#read, state__#write, event = MECH_steering_fail#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, MECH_steering_fail#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, MECH_steering_fail#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_MECH_steering_fail#FAULT := ((mode = NOMINAL & MECH_steering_fail.trans_trig_guard_#0) | (mode = MECH_steering_fail#FAULT & MECH_steering_fail.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_MECH_steering_fail : state__#write;
TRUE : state__#read;
esac;
        mode_is_MECH_steering_fail := mode = MECH_steering_fail#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in MECH_steering_fail#failure <-> failed_to_off#event);

    TRANS case
((mode = MECH_steering_fail#FAULT & MECH_steering_fail.trans_trig_guard_#1) | (mode = NOMINAL & MECH_steering_fail.trans_trig_guard_#0)) : next(mode) = MECH_steering_fail#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE MECH_steering_fail_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        MECH_steering_failEM : MECH_steering_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE MECH_steering_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE braking_#Extended(cmd, init_state)
    VAR
        MECH_braking_failure : MECH_braking_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := MECH_braking_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE MECH_braking_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        MECH_braking_fail : MECH_braking_fail_fm_Mod(mode = NOMINAL, mode_is_MECH_braking_fail, term_#1, state__#read, state__#write, event = MECH_braking_fail#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, MECH_braking_fail#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, MECH_braking_fail#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_MECH_braking_fail#FAULT := ((mode = NOMINAL & MECH_braking_fail.trans_trig_guard_#0) | (mode = MECH_braking_fail#FAULT & MECH_braking_fail.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_MECH_braking_fail : state__#write;
TRUE : state__#read;
esac;
        mode_is_MECH_braking_fail := mode = MECH_braking_fail#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in MECH_braking_fail#failure <-> failed_to_off#event);

    TRANS case
((mode = MECH_braking_fail#FAULT & MECH_braking_fail.trans_trig_guard_#1) | (mode = NOMINAL & MECH_braking_fail.trans_trig_guard_#0)) : next(mode) = MECH_braking_fail#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE MECH_braking_fail_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        MECH_braking_failEM : MECH_braking_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE MECH_braking_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE conveyor_#Extended(cmd, init_state)
    VAR
        MECH_conveyor_failure : MECH_conveyor_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := MECH_conveyor_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE MECH_conveyor_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        MECH_conveyor_fail : MECH_conveyor_fail_fm_Mod(mode = NOMINAL, mode_is_MECH_conveyor_fail, term_#1, state__#read, state__#write, event = MECH_conveyor_fail#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, MECH_conveyor_fail#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, MECH_conveyor_fail#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_MECH_conveyor_fail#FAULT := ((mode = NOMINAL & MECH_conveyor_fail.trans_trig_guard_#0) | (mode = MECH_conveyor_fail#FAULT & MECH_conveyor_fail.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_MECH_conveyor_fail : state__#write;
TRUE : state__#read;
esac;
        mode_is_MECH_conveyor_fail := mode = MECH_conveyor_fail#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in MECH_conveyor_fail#failure <-> failed_to_off#event);

    TRANS case
((mode = MECH_conveyor_fail#FAULT & MECH_conveyor_fail.trans_trig_guard_#1) | (mode = NOMINAL & MECH_conveyor_fail.trans_trig_guard_#0)) : next(mode) = MECH_conveyor_fail#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE MECH_conveyor_fail_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        MECH_conveyor_failEM : MECH_conveyor_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE MECH_conveyor_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE Communication(cmd)
    VAR
        DBMS : database_#Extended(cmd[index_database], init_database);
        LTE : lte_#Extended(cmd[index_lte], init_lte);
    DEFINE
        init_lte := off;
        init_database := off;
        is_functional := (fault_event_failed_DBMS & fault_event_failed_lte);
        nominal_event_TS := LTE.nominal_event;
        nominal_event_CM := DBMS.nominal_event;
        fault_event_failed_lte := LTE.fault_event_stuck_at_off;
        fault_event_failed_DBMS := DBMS.fault_event_stuck_at_off;
        index_lte := 1;
        index_database := 0;

    DEFINE
        init_state_Comm := [init_database, init_lte];
        mode_event_Comm := [fault_event_Comm, nominal_event_Comm];
        nominal_event_Comm := [nominal_event_CM, nominal_event_TS];
        fault_event_Comm := [fault_event_failed_DBMS, fault_event_failed_lte];


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE database_#Extended(cmd, init_state)
    VAR
        COMM_database_failure : COMM_database_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := COMM_database_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE COMM_database_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        COMM_database_fail : COMM_database_fail_fm_Mod(mode = NOMINAL, mode_is_COMM_database_fail, term_#1, state__#read, state__#write, event = COMM_database_fail#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, COMM_database_fail#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, COMM_database_fail#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_COMM_database_fail#FAULT := ((mode = NOMINAL & COMM_database_fail.trans_trig_guard_#0) | (mode = COMM_database_fail#FAULT & COMM_database_fail.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_COMM_database_fail : state__#write;
TRUE : state__#read;
esac;
        mode_is_COMM_database_fail := mode = COMM_database_fail#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in COMM_database_fail#failure <-> failed_to_off#event);

    TRANS case
((mode = COMM_database_fail#FAULT & COMM_database_fail.trans_trig_guard_#1) | (mode = NOMINAL & COMM_database_fail.trans_trig_guard_#0)) : next(mode) = COMM_database_fail#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE COMM_database_fail_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        COMM_database_failEM : COMM_database_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE COMM_database_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE lte_#Extended(cmd, init_state)
    VAR
        COMM_lte_failure : COMM_lte_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := COMM_lte_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE COMM_lte_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        COMM_lte_fail : COMM_lte_fail_fm_Mod(mode = NOMINAL, mode_is_COMM_lte_fail, term_#1, state__#read, state__#write, event = COMM_lte_fail#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, COMM_lte_fail#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, COMM_lte_fail#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_COMM_lte_fail#FAULT := ((mode = NOMINAL & COMM_lte_fail.trans_trig_guard_#0) | (mode = COMM_lte_fail#FAULT & COMM_lte_fail.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_COMM_lte_fail : state__#write;
TRUE : state__#read;
esac;
        mode_is_COMM_lte_fail := mode = COMM_lte_fail#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in COMM_lte_fail#failure <-> failed_to_off#event);

    TRANS case
((mode = COMM_lte_fail#FAULT & COMM_lte_fail.trans_trig_guard_#1) | (mode = NOMINAL & COMM_lte_fail.trans_trig_guard_#0)) : next(mode) = COMM_lte_fail#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE COMM_lte_fail_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        COMM_lte_failEM : COMM_lte_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE COMM_lte_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE Interaction(cmd)
    VAR
        CMDG : commandgeneration_#Extended(cmd[index_command_generation], init_command_generation);
        CMDI : commandinterpretation_#Extended(cmd[index_command_interpretation], init_command_interpretation);
    DEFINE
        init_command_interpretation := off;
        init_command_generation := off;
        nominal_event_CMDI := CMDI.nominal_event;
        nominal_event_CMDG := CMDG.nominal_event;
        fault_event_command_misinterperated := CMDI.fault_event_stuck_at_off;
        fault_event_command_missed := CMDI.fault_event_stuck_at_off;
        fault_event_worng_command_generation := CMDG.fault_event_stuck_at_off;
        index_command_interpretation := 1;
        index_command_generation := 0;

    DEFINE
        init_state_Interaction := [init_command_generation, init_command_interpretation];
        mode_event_Interaction := [fault_event_Interaction, nominal_event_Interaction];
        nominal_event_Interaction := [nominal_event_CMDG, nominal_event_CMDI, nominal_event_CMDI];
        fault_event_Interaction := [fault_event_worng_command_generation, fault_event_command_missed, fault_event_command_misinterperated];


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE commandgeneration_#Extended(cmd, init_state)
    VAR
        INTERACT_CMDgeneration_failure : INTERACT_CMDgeneration_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := INTERACT_CMDgeneration_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE INTERACT_CMDgeneration_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        INTERACT_CMDgeneration_fail : INTERACT_CMDgeneration_fail_fm_Mod(mode = NOMINAL, mode_is_INTERACT_CMDgeneration_fail, term_#1, state__#read, state__#write, event = INTERACT_CMDgeneration_fail#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, INTERACT_CMDgeneration_fail#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, INTERACT_CMDgeneration_fail#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_INTERACT_CMDgeneration_fail#FAULT := ((mode = NOMINAL & INTERACT_CMDgeneration_fail.trans_trig_guard_#0) | (mode = INTERACT_CMDgeneration_fail#FAULT & INTERACT_CMDgeneration_fail.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_INTERACT_CMDgeneration_fail : state__#write;
TRUE : state__#read;
esac;
        mode_is_INTERACT_CMDgeneration_fail := mode = INTERACT_CMDgeneration_fail#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in INTERACT_CMDgeneration_fail#failure <-> failed_to_off#event);

    TRANS case
((mode = INTERACT_CMDgeneration_fail#FAULT & INTERACT_CMDgeneration_fail.trans_trig_guard_#1) | (mode = NOMINAL & INTERACT_CMDgeneration_fail.trans_trig_guard_#0)) : next(mode) = INTERACT_CMDgeneration_fail#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE INTERACT_CMDgeneration_fail_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        INTERACT_CMDgeneration_failEM : INTERACT_CMDgeneration_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE INTERACT_CMDgeneration_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE commandinterpretation_#Extended(cmd, init_state)
    VAR
        INTERACT_CMDinterpretation_failure : INTERACT_CMDinterpretation_failure_FM_Mod(state_#nominal, off, failed_to_off);
    VAR
        state_#nominal : {on, off};

    IVAR
        failed_to_off : boolean;
        fault_event_stuck_at_off : boolean;
        nominal_event : boolean;

    DEFINE
        is_on := state = on;
        is_off := state = off;
        state := INTERACT_CMDinterpretation_failure.state_#fault;

    ASSIGN
        init(state_#nominal) := init_state;
        next(state_#nominal) := case
cmd = cmd_on : on;
cmd = cmd_off : off;
TRUE : state;
esac;

    TRANS nominal_event = FALSE;

    TRANS fault_event_stuck_at_off = failed_to_off;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE INTERACT_CMDinterpretation_failure_FM_Mod(state__#read, term_#1, failed_to_off#event)
    VAR
        INTERACT_CMDinterpretation_fail : INTERACT_CMDinterpretation_fail_fm_Mod(mode = NOMINAL, mode_is_INTERACT_CMDinterpretation_fail, term_#1, state__#read, state__#write, event = INTERACT_CMDinterpretation_fail#failure, event = _#NoEvent);
    VAR
        mode : {NOMINAL, INTERACT_CMDinterpretation_fail#FAULT};
        state__#write : {on, off};

    IVAR
        event : {_#NoEvent, INTERACT_CMDinterpretation_fail#failure};

    DEFINE
        NoEvent := event = _#NoEvent;
        cando_INTERACT_CMDinterpretation_fail#FAULT := ((mode = NOMINAL & INTERACT_CMDinterpretation_fail.trans_trig_guard_#0) | (mode = INTERACT_CMDinterpretation_fail#FAULT & INTERACT_CMDinterpretation_fail.trans_trig_guard_#1));
        state_#fault := case
mode = NOMINAL : state__#read;
mode_is_INTERACT_CMDinterpretation_fail : state__#write;
TRUE : state__#read;
esac;
        mode_is_INTERACT_CMDinterpretation_fail := mode = INTERACT_CMDinterpretation_fail#FAULT;

    INIT mode = NOMINAL;

    TRANS (event in INTERACT_CMDinterpretation_fail#failure <-> failed_to_off#event);

    TRANS case
((mode = INTERACT_CMDinterpretation_fail#FAULT & INTERACT_CMDinterpretation_fail.trans_trig_guard_#1) | (mode = NOMINAL & INTERACT_CMDinterpretation_fail.trans_trig_guard_#0)) : next(mode) = INTERACT_CMDinterpretation_fail#FAULT;
TRUE : (next(mode) = mode & NoEvent);
esac;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE INTERACT_CMDinterpretation_fail_fm_Mod(is_nominal, is_fault, term, input, varout, _failure, ev_#NoEvent)
    VAR
        INTERACT_CMDinterpretation_failEM : INTERACT_CMDinterpretation_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout);
    DEFINE
        failure := _failure;
        NoEvent := ev_#NoEvent;
        trans_trig_guard_#0 := failure;
        trans_trig_guard_#1 := NoEvent;


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE INTERACT_CMDinterpretation_fail_fm_EM_Mod(is_nominal, is_fault, term, input, varout)
    TRANS (!(!is_fault & next(is_fault)) | next(varout) = term);

    TRANS (!(is_fault & next(is_fault)) | next(varout) = varout);

    TRANS (!(is_nominal & next(is_nominal)) | next(varout) = varout);


-- ===============================================================================
--                               End of module
-- ===============================================================================

-- ===============================================================================
MODULE MasterCC#

-- ===============================================================================
--                               End of module
-- ===============================================================================
